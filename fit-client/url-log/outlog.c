#include <syslog.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>

//"pptpdurllog" : "1" 'pptpdserverip': 'time:username': 'user_logon_ip(pptp_peer_ip)' : 'url'
//				: 本机IP 。：   本地时间：读取本地数组：
//"pptpdurllog" : "2" 'pptpdserverip': 'time:username': 'user_logon_ip(pptp_peer_ip)' : 'on '/off
struct outlog_ctx_st
{
	int msg_num;
	pthread_mutex_t mutex;
	msg_list_t	msg_head;
}outlog_ctx;

int outlog()
{
	
	openlog("pptpd_urllog",  LOG_CONS | LOG_PID, LOG_USER);
	
	syslog(LOG_INFO,"-----info----This is a syslog test message generated by program '%s'\n","dd");
	syslog(LOG_ERR,"-----err----This is a syslog test message generated by program '%s'\n","bb");
	syslog(LOG_DEBUG,"-----debug----This is a syslog test message generated by program '%s'\n","cc");
	
	closelog();
	return 0;
}

void* log_mgr_pthread(void* arg)
{
	
}
//
log_mgr_start()
{
	pthread_t tid;
	openlog("pptpd_urllog",  LOG_CONS | LOG_PID, LOG_USER);
	TAILQ_INIT(&outlog_ctx.msg_head);
	
	if(pthread_create(&tid,NULL,log_mgr_pthread,(void*)fd)){
		printf("Create pptp_user_mgr fail!\n");
		return -1;
	}
	return tid;
}
void __send_logon_msg(char* msg,int len)
{
	char time_str[40];
	char* username = "user_qq";
	char* pptpd_server_ip = "192.168.3.4";
	char* peer_ip = "202.2.2.2";
	char* logon = "on";
	
	logon_msg_t* lmsg = (logon_msg_t*)msg;
	 
	ctime_r(&lmsg->time,time_str);
	time_str[strlen(time_str)-1] = '\0';
	//to do it;
	syslog(LOG_INFO,"LOGON_OFF %s %s %s %s %s",
		pptpd_server_ip,time_str,peer_ip,logon);
	return;
}
void __send_url_msg(char* msg,int len)
{
	return;
}
int output_msg(struct outlog_ctx_st* _ctx )
{
	
	__msg_entry_t* entry = NULL;
	__msg_entry_t* entry_next = NULL;
	pthead_mutex_lock(*_ctx->mutex);
	TAILQ_FOREACH_SAFE(entry,&_ctx->msg_head,node,entry_next)
	{
		switch(entry->enum_msg_type)
		{
			case URL_MSG_TYPE:
				__send_url_msg(entry->msg,entry->len);
			break;
			case LOGON_OFF_MSG_TYPE:
				__send_logon_msg(entry->msg,entry->len);
			break;
			default:
				break;
		}
	}
	
	pthead_mutex_unlock(*_ctx->mutex);
	return 0;
}


//
push_msg_to_log_list(enum enum_msg_type type,void* msg,int len)
{
	
	__msg_entry_t* entry = NULL;
	entry = malloc(sizeof(__msg_entry_t)+len);
	if(entry == NULL)
		return -1;
	
	time(&entry->time);
	entry->enum_msg_type = type;
	entry->len = len;
	
	memcpy(entry->msg,msg,len);
	pthead_mutex_lock(*outlog_ctx->mutex);
	TAILQ_INSERT_TAIL(&outlog_ctx->msg_head,entry,node);
	pthead_mutex_unlock(*outlog_ctx->mutex);
}
