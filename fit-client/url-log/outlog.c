 #include <sys/types.h>
 #include <syslog.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>  
#include <sys/un.h> 
#include <fcntl.h>
#include <sys/select.h>
#include <sys/time.h>
#include <stdlib.h>
#include <netdb.h>
#include "outlog.h"

#include "wake_utils.h"

#include "_u_log.h"


struct log_mgr_ctx
{

    struct in_addr syslog_ip;
    int sock;
    struct sockaddr_in server_addr; 
};
static struct log_mgr_ctx log_ctx;

//"pptpdurllog" : "1" 'pptpdserverip': 'time:username': 'user_logon_ip(pptp_peer_ip)' : 'url'
//				: 本机IP 。：   本地时间：读取本地数组：
//"pptpdurllog" : "2" 'pptpdserverip': 'time:username': 'user_logon_ip(pptp_peer_ip)' : 'on '/off


struct outlog_ctx_st
{
	int msg_num;
	msg_list_t	msg_head;
	pthread_mutex_t mutex;  //sync
	_wake_ wake;
};
struct outlog_ctx_st outlog_ctx;

int outlog()
{
	
	openlog("pptpd_urllog",  LOG_CONS | LOG_PID, LOG_USER);
	
//	syslog(LOG_INFO,"-----info----This is a syslog test message generated by program '%s'\n","dd");
//	syslog(LOG_ERR,"-----err----This is a syslog test message generated by program '%s'\n","bb");
//	syslog(LOG_DEBUG,"-----debug----This is a syslog test message generated by program '%s'\n","cc");
	
	closelog();
	return 0;
}


#define BUFFER_SIZE 1900
#define LOG_FACILITY_LOCAL_4  20
#define LOG_SEVERITY_NOTICE   5
int syslog_x(int log_level,char* msg,int len)
{
     char buffer[BUFFER_SIZE];
     int l;
     bzero(buffer, BUFFER_SIZE);
     l = sprintf(buffer,"<%d>",(LOG_FACILITY_LOCAL_4<<3)+LOG_SEVERITY_NOTICE); ///
     strncpy(buffer+l,msg,len);
     l = strlen(buffer);
     
     if(sendto(log_ctx.sock, buffer,l ,0,(struct sockaddr*)&log_ctx.server_addr,sizeof(log_ctx.server_addr)) < 0)   
     {
        _u_err_log("Send File Name Failed:%s",strerror(errno));
        
     }  
    return 0;
}
void __send_logon_msg(char* msg,int len)
{
	
    _u_log("%s:%d to syslog msg is <%s>\n",__func__,__LINE__,msg);
	syslog_x(LOG_INFO,msg,len);
	return;
}
void __send_url_msg(char* msg,int len)
{
         
    //ctime_r(&lmsg->time,time_str);
    //time_str[strlen(time_str)-1] = '\0';
    _u_log("%s:%d to syslog msg is <%.*s>",__func__,__LINE__,len,msg);
//printf("%s:%d\n",__func__,__LINE__);
    syslog_x(LOG_INFO,msg,len);
    return;
}
int output_msg(struct outlog_ctx_st* _ctx )
{
	
	__msg_entry_t* entry = NULL;
	__msg_entry_t* entry_next = NULL;
	
	pthread_mutex_lock(&_ctx->mutex);
	TAILQ_FOREACH_SAFE(entry,&_ctx->msg_head,node,entry_next)
	{

       // printf("%s:%d entry %p entry->msg_type %d \n",__func__,__LINE__,entry,entry->msg_type);
		switch(entry->msg_type)
		{
			case URL_MSG_TYPE:
				__send_url_msg(entry->msg,entry->len);
			break;
			case LOGON_OFF_MSG_TYPE:
				__send_logon_msg(entry->msg,entry->len);
			break;
			default:
				break;
		}
		TAILQ_REMOVE(&_ctx->msg_head,entry,node);
		free(entry);
	}
	
	pthread_mutex_unlock(&_ctx->mutex);
	return 0;
}

void* log_mgr_pthread(void* arg)
{
    while(1)
    {
        
        output_msg(&outlog_ctx);
        //printf("%s:%d\n",__func__,__LINE__);
	    sleep_down(&outlog_ctx.wake);
	}
}
int __get_syslog_ip_byname(char* name,struct in_addr* ret)
{
    struct addrinfo hints, *result,*curr;
    int s;
    struct sockaddr_in* sin_ip;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    s = getaddrinfo(name,NULL,&hints,&result);
    if(s != 0)
    {
        return -1;
    }
    for(curr = result; curr != NULL;curr = curr->ai_next)
    {
        sin_ip = (struct sockaddr_in*)result->ai_addr;
        memcpy(ret,&sin_ip->sin_addr,sizeof(struct in_addr));
        s = 0;
    }
    freeaddrinfo(result);
    return s;
}


int log_mgr_start(void)
{
	pthread_t tid;
	
    wake_init(&outlog_ctx.wake);
	
	TAILQ_INIT(&outlog_ctx.msg_head);
	
	//openlog("pptpd_urllog",  LOG_PID, LOG_USER);
    while(1)//must get syslog server's ip.
    {
        if(!__get_syslog_ip_byname("log.ipyun.cc",&log_ctx.syslog_ip))
        {
            _u_log("syslog server ip %x %s",log_ctx.syslog_ip.s_addr,inet_ntoa(log_ctx.syslog_ip));
            log_ctx.sock = socket(AF_INET,SOCK_DGRAM,0);
            if(log_ctx.sock < 0)
            {
                _u_err_log("cannot create  socket : %s",strerror(errno));  
                break;
            }
            log_ctx.server_addr.sin_family = AF_INET;
            log_ctx.server_addr.sin_addr.s_addr = log_ctx.syslog_ip.s_addr;
            log_ctx.server_addr.sin_port = htons(514);  
            break;
        }
        else
        {
            _u_err_log("cannot get syslog ip  %s. and get it again!",strerror(errno)); 
        }
    }
	
	if(pthread_create(&tid,NULL,log_mgr_pthread,(void*)0)){
		_u_err_log("Create pptp_user_mgr fail!\n");
		return -1;
	}
	return tid;
}

int push_msg_to_log_list(int type,void* msg,int len)
{

    __msg_entry_t* entry = NULL;
    entry = malloc(sizeof(__msg_entry_t)+len);
    if(entry == NULL){
        _u_err_log("malloc __msg_entry_t is failed!");
        return -1;
    }

    memset(entry,0,sizeof(__msg_entry_t)+len);
    entry->msg_type = type;
    entry->len = len;
    //_u_log("push msg type is %d len %d",type,len);
    memcpy(entry->msg,msg,len);
    pthread_mutex_lock(&outlog_ctx.mutex);
    TAILQ_INSERT_TAIL(&outlog_ctx.msg_head, entry, node);
    pthread_mutex_unlock(&outlog_ctx.mutex);
    wake_up(&outlog_ctx.wake);
    return 0;
}

