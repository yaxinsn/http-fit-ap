#include <syslog.h>
#include <errno.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>  
#include <sys/un.h> 
#include <fcntl.h>
#include <sys/select.h>
#include <sys/time.h>
#include <string.h>
#include <pthread.h>
#include "wake_utils.h"
#include "url_log.h"
#include <sys/queue.h>
#include <stdlib.h>

//"pptpdurllog" : "1" 'pptpdserverip': 'time:username': 'user_logon_ip(pptp_peer_ip)' : 'url'
//				: 本机IP 。：   本地时间：读取本地数组：
//"pptpdurllog" : "2" 'pptpdserverip': 'time:username': 'user_logon_ip(pptp_peer_ip)' : 'on '/off

#ifndef TAILQ_FOREACH_SAFE
#define TAILQ_FOREACH_SAFE(var,head,field,tvar)           \
    for((var) = TAILQ_FIRST((head));                    \
        (var) &&((tvar) = TAILQ_NEXT((var),field),1);   \
        (var) = (tvar))
#endif
struct outlog_ctx_st
{
	int msg_num;
	msg_list_t	msg_head;
	pthread_mutex_t mutex;  //sync
	_wake_ wake;
};
struct outlog_ctx_st outlog_ctx;

int outlog()
{
	
	openlog("pptpd_urllog",  LOG_CONS | LOG_PID, LOG_USER);
	
	syslog(LOG_INFO,"-----info----This is a syslog test message generated by program '%s'\n","dd");
	syslog(LOG_ERR,"-----err----This is a syslog test message generated by program '%s'\n","bb");
	syslog(LOG_DEBUG,"-----debug----This is a syslog test message generated by program '%s'\n","cc");
	
	closelog();
	return 0;
}
void __send_logon_msg(char* msg,int len)
{
	char time_str[40];
	char* username = "user_qq";
	char* pptpd_server_ip = "192.168.3.4";
	char* peer_ip = "202.2.2.2";
	char* logon = "on";
	
	logon_msg_t* lmsg = (logon_msg_t*)msg;
	 
	ctime_r(&lmsg->time,time_str);
	time_str[strlen(time_str)-1] = '\0';
	printf("%s:%d  msg is <%s>\n",__func__,__LINE__,msg);
	//todo it;
	syslog(LOG_INFO,"LOGON_OFF %s %s %s %s ",
		pptpd_server_ip,time_str,peer_ip,logon);
	return;
}
void __send_url_msg(char* msg,int len)
{
	return;
}
int output_msg(struct outlog_ctx_st* _ctx )
{
	
	__msg_entry_t* entry = NULL;
	__msg_entry_t* entry_next = NULL;
	
	pthread_mutex_lock(&_ctx->mutex);
	TAILQ_FOREACH_SAFE(entry,&_ctx->msg_head,node,entry_next)
	{
		switch(entry->msg_type)
		{
			case URL_MSG_TYPE:
				__send_url_msg(entry->msg,entry->len);
			break;
			case LOGON_OFF_MSG_TYPE:
				__send_logon_msg(entry->msg,entry->len);
			break;
			default:
				break;
		}
		TAILQ_REMOVE(&_ctx->msg_head,entry,node);
		free(entry);
	}
	
	pthread_mutex_unlock(&_ctx->mutex);
	return 0;
}

void* log_mgr_pthread(void* arg)
{
    while(1)
    {
        // todo
        output_msg(&outlog_ctx);
	    sleep_down(&outlog_ctx.wake);
	}
}
//
int log_mgr_start(void)
{
	pthread_t tid;
	openlog("pptpd_urllog",  LOG_CONS | LOG_PID, LOG_USER);

    wake_init(&outlog_ctx.wake);
	
	TAILQ_INIT(&outlog_ctx.msg_head);
	
	if(pthread_create(&tid,NULL,log_mgr_pthread,(void*)0)){
		printf("Create pptp_user_mgr fail!\n");
		return -1;
	}
	return tid;
}

int push_msg_to_log_list(enum enum_msg_type type,void* msg,int len)
{
	
	__msg_entry_t* entry = NULL;
	entry = malloc(sizeof(__msg_entry_t)+len);
	if(entry == NULL)
		return -1;
	
	time(&entry->time);
	entry->msg_type = type;
	entry->len = len;
	
	memcpy(entry->msg,msg,len);
	pthread_mutex_lock(&outlog_ctx.mutex);
	TAILQ_INSERT_TAIL(&outlog_ctx.msg_head, entry, node);
	pthread_mutex_unlock(&outlog_ctx.mutex);
	wake_up(&outlog_ctx.wake);
	return 0;
}
