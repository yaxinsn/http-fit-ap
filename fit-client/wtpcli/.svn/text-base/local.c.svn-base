#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/un.h>

#include <utils/utils.h>
#include <utils/vty.h>
#include <utils/command.h>
#include <utils/thread.h>
#include <utils/buffer.h>
#include <utils/network.h>

#include "local.h"


struct cmd_node vamd_node = {
	VAMD_NODE,
	"%s: ",
} ;
struct cmd_node vcsd_node = {
	VCSD_NODE,
	"%s: ",
} ;
struct cmd_node vamd_tech_node = {
	VAMD_TECH_NODE,
	"%s: ",
} ;
struct cmd_node vcsd_tech_node = {
	VCSD_TECH_NODE,
	"%s: ",
} ;

extern struct thread_master * master  ;
static vector files = NULL ;
vpipe_t * gVAMD = NULL ;
vpipe_t * gVCSD = NULL ;

#define VTY_GET_HOST(_name,_var,_max,_str) do { \
    char * eptr = NULL ; \
    struct in_addr addr = { 0,} ; \
    int len_ = snprintf(_var, _max, "%s", _str) ;\
    if( len_ >= _max ) { \
        vty_out(vty, "%% %s length overflow: %s%s", _name, _str, VTY_NEWLINE);\
        return CMD_WARNING; \
    } \
    if( inet_aton(_var, &addr) != 0 ) { \
        strtok_r(_var, "\"\'|,;$(){}#%*-", &eptr) ; \
        if( eptr && *eptr ) { \
            vty_out(vty, "%% Invalid %s : %s%s", _name, _str, VTY_NEWLINE); \
            return CMD_WARNING; \
        } \
    } \
}while(0)
#define VTY_GET_USER(_name,_var,_max,_str) do { \
    char * eptr = NULL ; \
    int len_ = snprintf(_var, _max, "%s", _str) ;\
    if( len_ >= _max ) { \
        vty_out(vty, "%% %s length overflow: %s%s", _name, _str, VTY_NEWLINE);\
        return CMD_WARNING; \
    } \
    strtok_r(_var, "\"\'|,;$(){}#%*", &eptr) ; \
    if( eptr && *eptr ) { \
        vty_out(vty, "%% Invalid %s : %s%s", _name, _str, VTY_NEWLINE); \
        return CMD_WARNING; \
    } \
}while(0)
#define VTY_GET_PASS(_name,_var,_max,_str) do { \
    char * eptr = NULL ; \
    int len_ = snprintf(_var, _max, "%s", _str) ;\
    if( len_ >= _max ) { \
        vty_out(vty, "%% %s length overflow: %s%s", _name, _str, VTY_NEWLINE);\
        return CMD_WARNING; \
    } \
    strtok_r(_var, "\"\'|", &eptr) ; \
    if( eptr && *eptr ) { \
        vty_out(vty, "%% Invalid %s : %s%s", _name, _str, VTY_NEWLINE); \
        return CMD_WARNING; \
    } \
}while(0)

int ioswap(int in, int out)
{
	int  ret;
	int  wlen;
	int  rlen;
	int  sum;
	char buf[1024] ;

	sum = 0 ;
	while(1) {
		rlen = read(in, buf, sizeof(buf)) ;
		if( rlen <= 0 ) {
			if( rlen < 0 ) {
				if( EINTR == errno ) continue ;
				if( EAGAIN== errno ) break ;
			}
			return -2 ;
		}

		for(wlen=0; wlen<rlen; ) {
			ret = write(out, buf+wlen, rlen-wlen) ;
			if( ret <= 0 ) {
				if( ret < 0 ) {
					if( EINTR == errno ) continue;
					if( EAGAIN== errno ) { usleep(50); continue;} 
				}

				return -3 ;
			}

			wlen+= ret ;
		}

		sum += wlen ;
	}

	return sum ;
}

/* hidden prompt output */
static int __vty_write(struct thread *t)
{
	struct vty * vty = THREAD_ARG(t);
	vty->t_write = NULL ;
	return 0;
}
static int __vty_read(struct thread *t)
{
	int ret;
	struct vty * vty = THREAD_ARG(t);
	vpipe_t *pipe    = vty->index_sub;
	vty->t_read = NULL ;
	THREAD_READ_ON(master, vty->t_read, __vty_read, vty, vty->fd);

	ret = ioswap(vty->fd, pipe->fd);
	if( ret < 0 ) {
		// return console 
		vpipe_close(pipe);
		return -1 ;
	}

	// RESET VTY TIMEOUT
	vty_alive(vty);

	return 0;
}
static int __vty_read2(struct thread *t)
{
	int ret;
	char buf[128]; 
	int cnt = 0;
	struct vty * vty = THREAD_ARG(t);
	vpipe_t *pipe    = vty->index_sub;

	vty->t_read = NULL ;
	THREAD_READ_ON(master, vty->t_read, __vty_read2, vty, vty->fd);

	ret = read(vty->fd, buf, sizeof(buf));
	//PRINT("read %d", ret);
	if( ret < 0 ) {
		return -1 ;
	} else if( 0 == ret ) {
		// tmpl_close();
		return 0 ;
	}
	
	writen(pipe->fd, buf, ret);

	if( vty->echo == ECHO_ON ) {
		writen(vty->fd, buf, ret);
	} else {
		int n; 
		for(n=0, cnt=0; n<ret; n++) {
			if( buf[n] == '\r' || buf[n] == '\n' ) {
				cnt++;
			}
		}
		if( cnt > 0 ) {
			writen(vty->fd, "\r\n", 2);
		}
	}
	
	//PRINT("CNT=%d, ECHO=%d", cnt, vty->echo);

	// RESET VTY TIMEOUT 
	vty_alive(vty);

	return 0;
}

void tmpl_commit(vpipe_t *pipe, int crlf){
	int ret;
	char cmd[64] ;
	struct vty * vty = pipe->vty ;

	THREAD_TIMER_OFF(pipe->t_comp);

	memset(cmd, 0, sizeof(cmd));
	ret = buffer_get_at(pipe->b, 0, cmd, sizeof(cmd)) ;
	if( ret <= 0 ) {
		return ;
	}

	if( ret > 11 && 0 == strncmp(cmd, "##COMMAND##", 11) ) {
		char * tag = cmd + 11 ;
		// PRINT("line = %s  -> tag = %s", cmd, tag);
		if( 0 == strncmp(tag, "PROMPT" , 6) ) {
			// line up 
			if( pipe->prompt ) {
				pipe->prompt(pipe);
			}
		} else if( 0 == strncmp(tag, "ECHO_OFF", 8) ) {
			if( vty ) {
				vty->echo = ECHO_OFF; 
			}
			// echo off 
		} else if( 0 == strncmp(tag, "ECHO_ON", 7) ) {
			if( vty ) {
				vty->echo = ECHO_ON ;
			}
			// echo on
		} else if( 0 == strncmp(tag, "PREFIX", 6) ) {
			// host.name 
			snprintf(pipe->prefix, sizeof(pipe->prefix), "%.*s", (int)sizeof(cmd)-11-6-1, tag+6+1);
			//PRINT("(%p)PREFIX = %s/ %s",pipe, tag+6+1, pipe->prefix);
		} else if( 0 == strncmp(tag, "COMPANY",7) ) {
			// motd 
			snprintf(pipe->company, sizeof(pipe->company), "%.*s", (int)sizeof(cmd)-11-7-1, tag+7+1);
			//PRINT("(%p)COMPANY = %s/ %s",pipe, tag+7+1, pipe->company);
		} else if( 0 == strncmp(tag, "SERIAL", 6) ) {
			// serial identify 
			snprintf(pipe->serial, sizeof(pipe->serial), "%.*s", (int)sizeof(cmd)-11-6-1, tag+6+1);
			//PRINT("(%p)SERIAL = %s/ %s",pipe, tag+6+1, pipe->serial);
		} else if( 0 == strncmp(tag, "ADDRESS",7) ) {
				snprintf(pipe->addr, sizeof(pipe->addr), "%.*s", (int)sizeof(cmd)-11-7-1, tag+7+1);
		}

		// ##command## do not output 
		buffer_reset(pipe->b);
		return ;
	}

	if( vty ) {
		//PRINT("##flush## %d", vty->fd );
		if( crlf ) {
			buffer_putstr(pipe->b, VTY_NEWLINE);
		}
		buffer_flush_all(pipe->b, vty->fd);
	} else {
		buffer_reset(pipe->b);
	}
	
	return ;
}

static int __tmpl_autocmp(struct thread *t)
{
	vpipe_t * pipe = THREAD_ARG(t) ;

	pipe->t_comp = NULL ;

	tmpl_commit(pipe, 0);

	return 0;
}
static int __tmpl_prompt(vpipe_t *pipe) 
{
	struct vty * vty = pipe->vty ;
	if( vty ) {
		vty->echo = ECHO_ON ;
		THREAD_READ_OFF(vty->t_read);
		THREAD_WRITE_OFF(vty->t_write);
		THREAD_READ_ON(master, vty->t_read, vty_read, vty, vty->fd);
		THREAD_WRITE_ON(master, vty->t_write, vty_flush, vty, vty->fd);
	}
	return 0;
}
static int __tmpl_close(vpipe_t *pipe)
{
	exit(0);
	return 0;
}

void tmpl_recv(vpipe_t *pipe, unsigned char * buf, int len)
{
	int i; 

	for(i=0; i<len; i++) {
		switch(buf[i]) {
			case '\r' :
			case '\n' :
				tmpl_commit(pipe, 1);
				break; 
			default :
				if( !isascii((int)buf[i]) || !iscntrl((int)buf[i]) )
					buffer_putc(pipe->b, buf[i]);
				break;
		}
	}

	return ;
}

void tmpl_bind(struct vty *vty, vpipe_t*pipe)
{
	char name[128] ;
	vpipe_t * old = NULL ;
	if( NULL == pipe ) return ;

	// unbind all 
	if( gVAMD )gVAMD->vty = NULL;
	if( gVCSD )gVCSD->vty = NULL;

	// binding 
	old = vty->index_sub; 
	vty->index_sub = pipe ;
	pipe->vty = vty ;
	vty->node = (pipe == gVCSD) ? VCSD_NODE: VAMD_NODE ;
	write(pipe->fd, "\r\n", 2);

	// clear up vty output buffer 
	buffer_reset(vty->obuf);
	
	// setup vty hostname 
	if( host.name ) {
		XFREE(MTYPE_TMP, host.name);
		host.name = NULL ;
	}
	snprintf(name, sizeof(name), "%s@[%s]", pipe->prefix, pipe->addr);
	host.name = XSTRDUP(MTYPE_TMP, name) ;
	
	// wellcome 
	if( 0 == pipe->count ) {
		// clear first prompt 
		vty_out(vty, "\r\n") ;
		vty_out(vty, " Welcome %s Remote Console \r\n\r\n", pipe->company);
		vty_out(vty, " %s %s %s\r\n\r\n",
			pipe->prefix, pipe->motd, pipe->serial) ;
	} else {
		vty_out(vty, "\r\n") ;
	}
	// leaving infomation 
	if( NULL == old ) {
		vty_out(vty, " Press return for console:") ;
	} else {
		vty_out(vty, " Entering console ... \r\n");
	}
	// inc 
	pipe->count ++ ;
}

static int tmpl_read(struct thread *t)
{
	int n ;
	unsigned char buf[512];
	vpipe_t * pipe = THREAD_ARG(t);

	pipe->t_read = NULL ;
	THREAD_READ_ON(master, pipe->t_read, tmpl_read, pipe, pipe->fd);

	n = read(pipe->fd, buf, sizeof(buf));
	if( 0 == n ) {
		// todo: tmpl_close();
		PERROR("READ %d: %d: %.*s", pipe->fd, n, (n>0)?n:0, buf );
		if( pipe->close ) {
			pipe->close(pipe);
		}
		return -1 ;
	} else if( n < 0 ) {
		if( EAGAIN == errno || EWOULDBLOCK == errno ) 
			return 0 ;
		// todo: tmpl_close();
		PERROR("READ %d: %d: %.*s", pipe->fd, n, (n>0)?n:0, buf );
		if( pipe->close ) {
			pipe->close(pipe);
		}
		return -2 ;
	}

	tmpl_recv(pipe, buf, n);

	THREAD_TIMER_OFF(pipe->t_comp);
	THREAD_TIMER_MSEC_ON(master, pipe->t_comp, __tmpl_autocmp, pipe, 500);

	return 0;
}

int tmpl_live(struct thread * t)
{
	vpipe_t * pipe = THREAD_ARG(t);

	pipe->t_live = NULL;
	THREAD_TIMER_ON(master,pipe->t_live, tmpl_live, pipe, 60);

	if( 1 != write(pipe->fd, "\n", 1) ) {
		;
	}

	return 0;
}

vpipe_t * tmpl_connect(const char * path, const char * type)
{
	int fd ;
	int ret;
	vpipe_t * pipe = NULL ;
	vpipe_t * old  = NULL ;
	struct sockaddr_un su; 

	fd = socket(AF_UNIX, SOCK_STREAM, IPPROTO_IP);
	if( fd < 0 ) {
		//PERROR("socket");
		return NULL ;
	}

	memset(&su, 0, sizeof(su));
	su.sun_family = AF_UNIX ;
	snprintf(su.sun_path, sizeof(su.sun_path), "%s", path) ;

	ret = connect(fd, &su, SUN_LEN(&su)) ;
	if( ret != 0 ) {
		//PERROR("connect");
		close(fd);
		return NULL ;
	}

	set_nonblocking(fd); 

	pipe = (vpipe_t*)XCALLOC(MTYPE_TMP, sizeof(vpipe_t));
	if( NULL == pipe ) {
		//PERROR("alloc");
		close(fd) ;
		return NULL ;
	}

	pipe->type = PIPE_DAEMON;
	pipe->fd = fd ;
	pipe->pid= 0 ;
	pipe->b = buffer_new(1024);
	pipe->prompt = __tmpl_prompt; /* default prompt process: return console */
	pipe->close  = __tmpl_close ; /* default io-close process: exit */
	snprintf(pipe->motd, sizeof(pipe->motd), "%s", type);
	if( NULL != (old = pipe->index_sub) ) {
		old->vty = NULL;
	}

	/* read out all greeting */
	if( 1 )
	{
		fd_set rd ;
		struct timeval exp = {5,0} ;
		unsigned char buf[128] ;

		//write(fd, "\n\n", 2) ;
		
		while( exp.tv_sec || exp.tv_usec ) {
			FD_ZERO(&rd);
			FD_SET(fd, &rd);
			ret = select(fd+1, &rd, NULL, NULL, &exp) ;
			//PRINT("SELECT = %d (fd = %d)", ret, fd);
			if( ret > 0 ) {
				ret = read(fd, buf, sizeof(buf)) ;
				if( ret > 0 ) {
					//PRINT("READ %d: %.*s", ret, ret, buf);
					tmpl_recv(pipe, buf, ret);
				} else if( 0 == ret ) {
					int status =0,  sret=0;
					socklen_t slen = sizeof(status) ;
					sret = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&status, &slen);
					PERROR("pipe broken: read result = %d, gopt = %d, status = %d, slen = %d", 
						ret, sret, status, slen);
					close(fd);
					buffer_free(pipe->b);
					XFREE(MTYPE_TMP, pipe);
					return NULL ;
				}
			}
			if( *pipe->company && *pipe->prefix &&
			    *pipe->serial  && *pipe->addr ) break;
		}
	}

	/* start read event */
	THREAD_READ_ON(master, pipe->t_read, tmpl_read, pipe, pipe->fd);

	/* auto send '\n' to get the first prompt */
	THREAD_TIMER_ON(master,pipe->t_live, tmpl_live, pipe, 0);


	return pipe ;
}

int tmpl_prepare(struct vty *vty, struct cmd_element *cmd, char * buf, int maxsiz) 
{
	int i, j, type;
	int varflag = 0;
	int    len ;
	char * opt;
	int    argc = 0 ;
	char * argv[CMD_ARGC_MAX] ;
	vector descvec;
	vector vline;
	struct desc * desc , *match;

	vline = cmd_make_strvec(vty->buf);
	if( !vline ) return CMD_WARNING;

	for(i=0; i<vector_active(vline); i++) {
		opt = vector_slot(vline, i);
	    len = strlen(opt) ;
	    
		if (varflag) {
			argv[argc++] = vector_slot (vline, i);
		} else {
			descvec = vector_slot (cmd->strvec, i);

			if (vector_active (descvec) == 1)
			{
				struct desc *desc = vector_slot (descvec, 0);

				if (CMD_VARARG (desc->cmd))
					varflag = 1;

				if (varflag || CMD_VARIABLE (desc->cmd) || CMD_OPTION (desc->cmd))
					argv[argc++] = vector_slot (vline, i);
				else
					argv[argc++] = desc->cmd ;
			} else { 
				type  = 0 ;
				match = NULL ;
				for(j=0; j<vector_active(descvec) ; j++) {
					desc = vector_slot(descvec, j) ;

					if( CMD_VARIABLE(desc->cmd) ) {
						if( type < 1 ) {
							type = 1 ;
							match= desc;
						}
					} else if( 0 == strncmp(opt, desc->cmd, len) ) {
						if( type < 1000 + len ) {
							type = 1000 + len; 
							match= desc ;
						}
					} else if( NULL == match ) {
						match = desc ;
					}
				}
				if( CMD_VARIABLE(match->cmd) ) {
				    argv[argc++] = opt;
				} else {
					argv[argc++] = match->cmd ;
				}
			}
		}

		if (argc >= CMD_ARGC_MAX) {
			cmd_free_strvec(vline);
			return CMD_ERR_EXEED_ARGC_MAX;
		}
	}

	opt = argv_concat((const char**)argv, argc, 0);
	cmd_free_strvec(vline);
	if( !opt ) {
		return CMD_ERR_NOTHING_TODO;
	}
	
	len = snprintf(buf, maxsiz, "%s", opt) ;
	XFREE(MTYPE_TMP, opt);

	if( len >= maxsiz ) {
		return CMD_ERR_EXEED_ARGC_MAX ;
	}

	// 
	return 0 ;
}

int tmpl_execute(struct vty *vty, struct cmd_element *cmd)
{
	int ret;
	int len;
	char line[1024] ;
	vpipe_t * pipe = vty->index_sub ;
	
	// command prepare
	ret = tmpl_prepare(vty, cmd, line, sizeof(line));
	//vty_out(vty,"%d : %p : %p : %s%s", ret, vty->index, vty->index_sub, line, VTY_NEWLINE);

	if( pipe ) {
		len = strnlen(line, sizeof(line)-1);
		line[len++] = '\n' ;

		ret = write(pipe->fd, line, len) ;
//		PRINT("WRITE %d -> %d", pipe->fd, ret );
		//vty_out(vty, "length %d, writed %d%s", len, ret, VTY_NEWLINE);

		/* hack vty I/O */
		write(vty->fd, "\r\n", 2) ;
		THREAD_READ_OFF(vty->t_read);
		THREAD_WRITE_OFF(vty->t_write);
		THREAD_READ_ON(master, vty->t_read, __vty_read2, vty, vty->fd);
		THREAD_WRITE_ON(master,vty->t_write,__vty_write,vty, vty->fd);
	}
	

	return 0;
}

void vpipe_close(vpipe_t * pipe)
{
	int status;
	vpipe_t * old = NULL;
	struct vty * vty= pipe->vty;

	// return vty 
	THREAD_READ_OFF(vty->t_read);
	THREAD_WRITE_OFF(vty->t_write);
	THREAD_READ_ON(master , vty->t_read, vty_read, vty, vty->fd);
	THREAD_WRITE_ON(master,vty->t_write,vty_flush, vty, vty->fd);
	vty->index_sub = pipe->index_sub;
	if( NULL != (old=vty->index_sub) ) {
		old->vty = vty ;
	}

	if( pipe->type == PIPE_REMOTE ) {
		vty_out(vty, "Press 'Enter' return console : ");
	}
	
	// close pipe 
	THREAD_TIMER_OFF(pipe->t_comp);
	THREAD_TIMER_OFF(pipe->t_expr);
	THREAD_READ_OFF(pipe->t_read);
	THREAD_TIMER_OFF(pipe->t_live);
	
	close(pipe->fd);
	if( pipe->pid > 0 ) {
		if( 0 == kill(pipe->pid, 0) ) {
			kill(pipe->pid, SIGKILL);
		}
		waitpid(pipe->pid, &status, WNOHANG);
	}
	XFREE(MTYPE_TMP, pipe);

}
static int vpipe_expr(struct thread *t)
{
	vpipe_t * pipe = THREAD_ARG(t);

	pipe->t_expr = NULL ;
	vpipe_close(pipe);

	return 0;
}

static int vpipe_read(struct thread *t)
{
	int ret ;
	vpipe_t * pipe = THREAD_ARG(t);
	struct vty * vty= pipe->vty ;

	pipe->t_read = NULL ;
	THREAD_TIMER_OFF(pipe->t_expr);
	THREAD_READ_ON(master, pipe->t_read, vpipe_read,   pipe, pipe->fd);

	ret = ioswap(pipe->fd, vty->fd);
	if( ret < 0 ) {
		vpipe_close(pipe);
		return -1;
	}
	return 0;
}

static int vpipe_run(struct vty * vty, char * cmd)
{
	int fd ;
	pid_t pid;
	vpipe_t * old ;
	vpipe_t * pipe;

	pid = forkpty(&fd, NULL, NULL, NULL) ;
	if( pid < 0 ) {
		vty_out(vty, "Can not execute command%s", VTY_NEWLINE);
		return -1 ;
	}

	// child 
	if( 0 == pid ) {
		setuid(0); 
		setenv("PATH","/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin",1);
		printf("\r\n");
		execl("/bin/sh", "sh", "-c" , cmd, NULL) ;
		exit(0) ;
	}

	// parent 
	pipe = XCALLOC(1, sizeof(vpipe_t));
	if( NULL == pipe ) {
		close(fd); 
		waitpid(pid, &fd, WNOHANG) ;
		vty_out(vty, "Can not alloc memory%s", VTY_NEWLINE);
		return -2;
	}

	// bind to
	set_nonblocking(fd);
	pipe->type = PIPE_EXECUTE;
	pipe->fd = fd ;
	pipe->vty= vty;
	pipe->pid= pid;
	pipe->index_sub = vty->index_sub;
	vty->index_sub  = pipe ;
	if( NULL != (old = pipe->index_sub) ) {
		old->vty = NULL;
	}
	
	THREAD_READ_OFF(vty->t_read);
	THREAD_WRITE_OFF(vty->t_write);
	vty_alive(vty);
	
	THREAD_READ_ON(master, vty->t_read,  __vty_read,  vty, vty->fd);
	THREAD_WRITE_ON(master,vty->t_write, __vty_write, vty, vty->fd);
	THREAD_READ_ON(master, pipe->t_read, vpipe_read,  pipe, pipe->fd);
	THREAD_TIMER_ON(master,pipe->t_expr, vpipe_expr,  pipe, 120);

	return 0;
}
#define __LOCAL_PING__
DEFUN(local_ping,
      local_ping_host_cmd,
      "ping A.B.C.D",
      "Network ping\nHost IP address\n")
{
	char cmd[128] ;

	if( argc == 2 ) {
		snprintf(cmd, sizeof(cmd), "ping -c %s %s", argv[0], argv[1]) ;
	} else {
		if( self == &local_ping_host_cmd )
			snprintf(cmd, sizeof(cmd), "ping -c 4 %s", argv[0]) ;
		else
			snprintf(cmd, sizeof(cmd), "ping %s", argv[0]);
	}

	vpipe_run(vty, cmd);
	
	return CMD_SUCCESS ;
}
ALIAS(local_ping,
      local_ping_long_host_cmd,
      "ping -t A.B.C.D",
      "Network ping\nLong ping option\nHost IP address\n");

ALIAS(local_ping,
      local_ping_count_host_cmd,
      "ping -c <1-65535> A.B.C.D",
	  "Network ping\n"
	  "Packet number option\nNumber of packets\nHost IP address\n");

#define __LOCAL_CLI_TYPE__

DEFUN(local_cli_switch,
      local_cli_switch_cmd,
      "cli (cs|am|vsm|csp)",
      "Command line interface module\nControl server mode\nAccess manager mode\nAccess manager mode\nControl server mode\n")
{
	if( *argv[0] == 'c' ) {
		if( vty->node == VCSD_NODE || vty->node == VCSD_TECH_NODE ) {
			vty_out(vty, "%% already control-server mode%s", VTY_NEWLINE);
			return CMD_WARNING;
		}
		if( NULL == gVCSD ) {
			gVCSD = tmpl_connect(CLI_PATH_VCSD);
			if( NULL == gVCSD ) {
				vty_out(vty, "%% Control-server not exist. %s", VTY_NEWLINE);
				return CMD_WARNING;
			}
		}
		tmpl_bind(vty, gVCSD);
	} else {
		if( vty->node == VAMD_NODE || vty->node == VAMD_TECH_NODE ) {
			vty_out(vty, "%% already access-manager mode%s", VTY_NEWLINE);
			return CMD_WARNING;
		}
		if( NULL == gVAMD ) {
			gVAMD = tmpl_connect(CLI_PATH_VAMD);
			if( NULL == gVAMD ) {
				vty_out(vty, "%% Access-manager not exist. %s", VTY_NEWLINE);
				return CMD_WARNING;
			}
		}
		tmpl_bind(vty, gVAMD);
	}
	return CMD_SUCCESS ;
}
#define __VNI_TECH__ 
DEFUN_HIDDEN(local_vni_tech,
      local_vni_tech_cmd,
      "vni tech",
      "\n\n") 
{
	if( vty->node == VCSD_TECH_NODE || vty->node == VAMD_TECH_NODE ) {
		vty_out(vty, "%% already tech supported%s", VTY_NEWLINE);
		return CMD_WARNING;
	}

	vty->index= (void*)(long)vty->node ;
	vty->node = AUTH_ENABLE_NODE ;
	return CMD_SUCCESS ;
}

#define __LOCAL_TCPDUMP__ 
DEFUN(local_tcpdump,
      local_tcpdump_cmd,
      "tcpdump",
      "Dumpping packet infomation\n")
{
	vpipe_run(vty, "tcpdump -i any -nvvv -s0") ;

	return CMD_SUCCESS;
}
DEFUN(local_tcpdump_expression,
      local_tcpdump_expression_cmd,
      "tcpdump .WORD",
      "Dumpping packet infomation\nExpressions (eg. tcp port 80)\n")
{
	int  len;
	int  n,i,sl ;
	char cmd[256] ;
	time_t now = 0;

	if( argc <= 0 ) 
		return CMD_WARNING ;

	// base command 
	len = snprintf(cmd, sizeof(cmd), "tcpdump -i any -nvvv -s0");

	// special filename 
	if( &local_tcpdump_expression_cmd != self ) {
		now = time(NULL);
		len += snprintf(cmd+len, sizeof(cmd)-len, " -w %lu.pcap", (uptr_t)now);
	}
	
	// expression checking 
	for(n=0; n<argc; n++) {
		sl = strlen(argv[n]) ;
		for( i=0; i<sl; i++) {
			if( ! (isalpha((int)argv[n][i])||isdigit((int)argv[n][i])) ) {
				vty_out(vty, "%% Bad expression name: %s%s", argv[n], VTY_NEWLINE);
				return CMD_WARNING;
			}
		}
		len += snprintf(cmd+len, sizeof(cmd)-len," %s", argv[n]) ;
	}
	if( len >= sizeof(cmd) ) {
		vty_out(vty, "%% Too many expressions.%s", VTY_NEWLINE);
		return CMD_WARNING ;
	}

	vpipe_run(vty, cmd);

	if( now > 0 ){
		struct desc * dc ;
		char name[32] ;
		char help[128];

		snprintf(name, sizeof(name), "%lu.pcap", (uptr_t)now);
		snprintf(help, sizeof(help), "Capture file at %s", ctime(&now));
		len = strnlen(help, sizeof(help)) ;
		if( len > 0 && len <128 && help[len-1] == '\n') {
			help[len-1] = 0 ;
		}
		
		vty_out(vty, "%% Saving as %u.pcap (tips, using 'scp' command to get this file) %s", (u32)now, VTY_NEWLINE);
		
		/* make up desc for scp/ftp command */
		dc = (struct desc*)XCALLOC(MTYPE_TMP, sizeof(struct desc));
		if( dc ) {
			dc->cmd = XSTRDUP(MTYPE_TMP, name);
			dc->str = XSTRDUP(MTYPE_TMP, help);
			vector_set(files, dc);
		}
	}

	return CMD_SUCCESS;
}
ALIAS(local_tcpdump_expression,
      local_tcpdump_save_expression_cmd,
      "tcpdump -w .WORD",
      "Dumpping packet infomation\nFile output option\nExpressions (eg. tcp port 80)\n") ;

/* file with XSTRDUP(MTYPE_TMP, xxx) */
int __file_complete(struct cmd_element*cmd, struct desc *dc, vector vec, char *str)
{
	int i ;
	int cnt ;
	struct desc *f ;
	if( !dc || !dc->cmd || 0 != strcmp(dc->cmd, "FILE") )
		return 0 ;

	for(i=0, cnt=0; i<vector_active(files); i++) {
		f = vector_slot(files, i) ;
		if( !f || !f->cmd || !f->str )
			continue ;

		if( NULL != str && 0 != strncmp(str, f->cmd, strlen(str)) )
			continue ;

		vector_set(vec, XSTRDUP (MTYPE_TMP, f->cmd)) ;
		cnt ++ ;
	}
	
	return ( cnt != 0 );
}
/* fill with desc */
int __file_describe(struct cmd_element*cmd, struct desc *dc, vector vec, char *str)
{
	int i ;
	int cnt ;
	struct desc *f ;
	if( !dc || !dc->cmd || 0 != strcmp(dc->cmd, "FILE") )
		return 0 ;

	for(i=0, cnt=0; i<vector_active(files); i++) {
		f = vector_slot(files, i) ;
		if( !f || !f->cmd || !f->str )
			continue ;

		if( NULL != str && 0 != strncmp(str, f->cmd, strlen(str)) )
			continue ;

		vector_set(vec, f) ;
		cnt ++ ;
	}
	
	return ( cnt != 0 );
}

#define __LOCAL_SCP__
DEFUN_FULL(local_scp, 
      local_scp_cmd, 
      __file_describe, __file_complete,
      "scp A.B.C.D USER FILE",
      "Special Containment Procedures\nServer IP address\nUser name on server\nFile name\n")
{
	int i;
    struct desc * f ;
	char cmd[256] ;
    char user[64] ;

	VTY_GET_USER("Username", user, sizeof(user), argv[1]);

	// check filename
    for(i=0; i<vector_active(files); i++) {
        f = vector_slot(files, i) ;
        if( !f || !f->cmd ) continue ;
        if( 0 == strcmp(argv[2], f->cmd) ) {
            break ;
        }
    }
    if( (i == vector_active(files)) || (0!=access(argv[2],F_OK)) ) {
		vty_out(vty, "%% File[%s] not exist%s", argv[2], VTY_NEWLINE);
		return CMD_WARNING;
	}

	snprintf(cmd, sizeof(cmd), "scp %s %s@%s:~/", argv[2], user, argv[0]); 
	vpipe_run(vty, cmd);

	return CMD_SUCCESS ;
}

#define __LOCAL_TIMEOUT__
DEFUN(local_timeout,
      local_timeout_cmd,
      "timeout <0-35791> <0-2147483>",
      "Configure terminal timeout\nMinutes of timeout\nSecond of timeout\n")
{
	unsigned long min =0, sec=0 ;

	VTY_GET_INTEGER_RANGE("minutes",min,argv[0],0,35791) ;
	if( argc >= 2 ) {
		VTY_GET_INTEGER_RANGE("second",sec,argv[1],0,2147483) ;
	}

	vty->v_timeout = min * 60 + sec ;
	
	vty_alive(vty);

	return CMD_SUCCESS;
}
ALIAS(local_timeout,
      local_timeout_min_cmd,
      "timeout <0-35791>",
      "Configure terminal timeout\nMinutes of timeout\n");

DEFUN(local_show_timeout,
      local_show_timeout_cmd,
      "show timeout",
      SHOW_STR "Configure terminal timeout\n")
{
	vty_out(vty, "Current terminal timeout: %lu:%02lu (%lu)%s",
		vty->v_timeout/60, vty->v_timeout%60, vty->v_timeout , VTY_NEWLINE ) ;
	return CMD_SUCCESS ;
}


#define __LOCAL_LOGIN_SERVICE 
typedef struct __login_service__ {
	int sk ;
	u32 port;
	char mac[32];
	struct thread * t_accept;
	struct thread * t_expire;
	struct vty * vty ;
} loginserv_t;

static loginserv_t LS = {
	.sk = -1 , .t_accept = NULL, .vty = NULL,
} ;

static int __login_accept( struct thread *t )
{
	int fd ;
	int sk = THREAD_FD(t);
	struct sockaddr_in addr;
	socklen_t slen = sizeof(addr);
	struct vty * vty = LS.vty ;
	vpipe_t * pipe = NULL ;

	LS.t_accept = NULL ;
	THREAD_TIMER_OFF(LS.t_expire);
	
	fd = accept(sk, (struct sockaddr*)&addr, &slen);
	// PRINT("SK= %d, FD=%d", sk, fd );
	close(sk);
	LS.sk = -1 ;
	
	if( fd < 0 ) {
		vty_out(LS.vty, "\r\n%% Login process failed(%s)\r\n", LS.mac);
		return 0;
	}

	pipe = (vpipe_t*)XCALLOC(MTYPE_TMP, sizeof(vpipe_t));
	if( NULL == pipe ) {
		vty_out(LS.vty, "\r\n%% Login process failed(%s), memory limit.\r\n", LS.mac);
		return 0;
	}

	// bind to
	set_nonblocking(fd);
	pipe->type = PIPE_REMOTE;
	pipe->fd = fd ;
	pipe->vty= vty;
	pipe->pid= 0;
	pipe->index_sub= vty->index_sub;
	vty->index_sub = pipe ;
	
	// hack vty I/O 
	THREAD_READ_OFF(vty->t_read);
	THREAD_WRITE_OFF(vty->t_write);
	vty_alive(vty);
	
	THREAD_READ_ON(master, vty->t_read, __vty_read, vty, vty->fd);
	THREAD_WRITE_ON(master,vty->t_write,__vty_write, vty, vty->fd);
	THREAD_READ_ON(master, pipe->t_read,vpipe_read,   pipe, pipe->fd);
	THREAD_TIMER_ON(master,pipe->t_expr,vpipe_expr,   pipe, 120);
	
	return 0;
}
static int __login_expire( struct thread *t )
{
	LS.t_expire = NULL; 
	THREAD_READ_OFF(LS.t_accept);
	close(LS.sk);
	LS.sk = -1 ;
	LS.vty=NULL;
	
	return 0;
}

int login_service(struct vty* vty, int * rport)
{
	int ret;
	int fd ;
	struct sockaddr_in addr;
	socklen_t slen;

	fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	if( fd < 0 ) {
		return -1; 
	}

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET ;
	addr.sin_port   = *rport ;
	ret = bind(fd, (struct sockaddr*)&addr, sizeof(addr));
	if( ret != 0 ) {
		close(fd) ;
		return -2 ;
	}

	slen = sizeof(addr) ;
	memset(&addr, 0, sizeof(addr));
	ret = getsockname(fd, &addr, &slen);
	if( ret != 0 ) {
		close(fd);
		return -3;
	}

	ret = listen(fd, 10) ;
	if( ret != 0 ) {
		close(fd);
		return -4;
	}

	LS.sk   = fd ;
	LS.vty  = vty;
	LS.port = htons(addr.sin_port);
	THREAD_READ_ON(master, LS.t_accept, __login_accept, NULL, fd);
	THREAD_TIMER_ON(master,LS.t_expire, __login_expire, NULL, 30);

	*rport = LS.port;

	return 0;
}

/* defined , but not installed */
DEFUN(local_login_mac_port,
      local_login_mac_port_cmd,
      "login X:X:X:X:X:X <1-65530>",
      "Login remote device\nDevice serial identify\nLocal port(tcp only)\n")
{
	int   port = 0 ;

	if( LS.sk >= 0 ) {
		vty_out(vty, "%% A login process is running. (%s)%s", LS.mac, VTY_NEWLINE);
		return CMD_WARNING;
	}

	if( argc == 2 ) {
		port = atoi(argv[1]);
	}

	if( 0 != login_service(vty,&port) ) {
		vty_out(vty, "Creating local service failed. %s", VTY_NEWLINE);
		return CMD_WARNING;
	}

	snprintf(LS.mac, sizeof(LS.mac), "%s", argv[0]);
	snprintf(vty->buf, vty->max, "login %s %d", argv[0], port) ;

	tmpl_execute(vty, &local_login_mac_port_cmd);

	snprintf(vty->buf, vty->max, "login %s", argv[0]) ;
	
	return CMD_SUCCESS ;
}
ALIAS(local_login_mac_port,
      local_login_mac_cmd,
      "login X:X:X:X:X:X",
      "Login remote device\nDevice serial identify\n");


#define __LOCAL_NSLOOKUP
DEFUN(local_nslookup,
      local_nslookup_cmd,
      "nslookup (A.B.C.D|DOMAIN)",
      "Query Internet name servers interactively\n"
      "Internet address\nInternet domain\n")
{
	char cmd[128];
    char host[64] ;

    VTY_GET_HOST("HOST", host, sizeof(host), argv[0]);
    snprintf(cmd, sizeof(cmd), "nslookup %s", host);
    vpipe_run(vty, cmd);

	return CMD_SUCCESS ;
}

#define __LOCAL_SHOW_TECH
DEFUN(local_show_tech,
	local_show_tech_cmd,
	"show tech",
	SHOW_STR "Show tech support information\n")
{
	FILE * fp = NULL;
	char line[1024] = {0};

	fp = fopen("/proc/fpp/client/clients","r");
	if(fp != NULL)
	{
		vty_out(vty,"======/proc/fpp/client/clients====================\n");
		while(fgets(line,sizeof(line)-1,fp)!=NULL)
		{
			vty_out(vty,"%s%s",line,VTY_NEWLINE);
		}
		fclose(fp);
	}

	fp = fopen("/proc/fpp/port/ports","r");
	if(fp != NULL)
	{
		vty_out(vty,"======/proc/fpp/port/ports =======================\n");
		while(fgets(line,sizeof(line)-1,fp)!=NULL)
		{
			vty_out(vty,"%s%s",line,VTY_NEWLINE);
		}
		fclose(fp);
	}
	
	buffer_flush_all(vty->obuf,vty->fd);

	tmpl_execute(vty,&local_show_tech_cmd);

	return CMD_SUCCESS;
}

#define __LOCAL_TRACEROUTE
DEFUN(local_traceroute,
      local_traceroute_cmd,
      "traceroute (A.B.C.D|DOMAIN)",
      "Network trace route\n"
      "Internet address\nInternet domain\n")
{
    int  ol, i ;
    char host[64] = {0, };
	char opts[32] = {0, };
	char cmd[128] 	= {'\0'};
    
	// arguments 
    for(i=0, ol=0; i<argc; i++) {
        if( argv[i][0] == '-' ) {
            ol += snprintf(opts+ol, sizeof(opts)-ol, "%s ", argv[i]);
        } else {
            VTY_GET_HOST("Host", host, sizeof(host), argv[i]) ;
        }
    } 

    i = snprintf(cmd, sizeof(cmd), "traceroute -w 3 -m 18 %s %s", opts, host) ;
    if( i >= sizeof(cmd) ) {
        vty_out(vty, "%% Length overflow: %s%s", argv[0], VTY_NEWLINE);
        return CMD_WARNING;
    }
	
	vpipe_run(vty, cmd);
	
	return CMD_SUCCESS;
}
ALIAS(local_traceroute,
      local_traceroute_options_cmd,
      "traceroute (-n|-I|-T) (A.B.C.D|DOMAIN)",
      "Network trace route\n"
      "Do not resolve IP address to their domain names\n""Use ICMP ECHO for tracerouting\nUse TCP SYN for tracerouting\n"
      "Internet address\nInternet domain\n");

#define __LOCAL_RADTEST
DEFUN(local_radtest,
      local_radtest_cmd,
      "radtest (-4|-6) (pap|chap|mschap|eap-md5) USERNAME PASSWORD (A.B.C.D|DOMAIN) <0-2147483647> SECRET",
      "RADIUS server test program\n"
      "Use IPv4 for the NAS address\nUse IPV6 for the NAS address\n"
      "Authentication type pap\nAuthentication type chap\nAuthentication type mschap\nAuthentication type eap-md5\n"
      "Specify a username\nSpecify a password\n"
      "Radius-server IP[:port]\nRadius server domain[:port]\n"
      "NAS port number\n"
      "Specifies the secret key to use\n")
{
    char user[64];
    char pass[64];
    char host[64];
    char secr[64];
    u32  port ;

	char cmd[256] 	= {'\0'};
	unsigned int len= 0;
	unsigned int off= 0;

	//default
	if(self == &local_radtest_cmd) {
        off = 2 ;
		len = snprintf(cmd, sizeof(cmd), "radtest %s -t %s ", argv[0], argv[1]) ; 
	} else {	
		len = snprintf(cmd, sizeof(cmd), "radtest ");
	}

	VTY_GET_USER("Username", user, sizeof(user), argv[off+0]);
    VTY_GET_PASS("Password", pass, sizeof(pass), argv[off+1]);
    VTY_GET_HOST("Host",     host, sizeof(host), argv[off+2]);
    VTY_GET_INTEGER_RANGE("NAS port number", port, argv[off+3],1,2147483647) ;
    VTY_GET_PASS("Secret",   secr, sizeof(secr), argv[off+4]);
	len += snprintf(cmd+len, sizeof(cmd)-len, "%s \'%s\' %s %u \'%s\'", user, pass, host, port, secr);
	
	if(len >= sizeof(cmd))
	{
		vty_out(vty, "%% Length overflow: %s%s", cmd, VTY_NEWLINE);
		return CMD_WARNING;
	}
	
	vpipe_run(vty, cmd);
	return CMD_SUCCESS;
}

ALIAS(local_radtest,
      local_radtest_simple_cmd,
      "radtest WORD WORD (A.B.C.D|DOMAIN) <0-2147483647> WORD",
      "RADIUS server test program\n"
      "Specify a username\nSpecify a password\n"
      "Radius-server IP[:port]\nRadius server domain[:port]\n"
      "NAS port number\n"
      "Specifies the secret key to use\n")


#define __LOCAL_SSH__
DEFUN(local_ssh_user_host,
      local_ssh_user_host_cmd,
      "ssh USER (HOST|A.B.C.D)",
      "Start SSH connection\nSSH username\nSSH server domain\nSSH server address\n")
{
    char user[64] ;
    char host[64] ;
	char cmd[256] ;

	VTY_GET_USER("SSH-user",   user, sizeof(user), argv[0]);
    VTY_GET_HOST("SSH-server", host, sizeof(host), argv[1]);
    
	if( argc == 3 ) {
		snprintf(cmd, sizeof(cmd), "ssh -l %s -p %s %s", user, argv[2], host) ;
	} else {
		snprintf(cmd, sizeof(cmd), "ssh -l %s %s", user, host) ;
    }

    vpipe_run(vty, cmd);

    return CMD_SUCCESS ;
}
ALIAS(local_ssh_user_host,
      local_ssh_user_host_port_cmd,
      "ssh USER (HOST|A.B.C.D) <1-65535>",
      "Start SSH connection\nSSH username\nSSH server domain\nSSH server address\nSSH server port\n")

#define __LOCAL_TELNET__
DEFUN(local_telnet_host,
      local_telnet_host_cmd,
      "telnet (HOST|A.B.C.D)",
      "Start telnet connection\nTelnet server domain\nTelnet server address\n")
{
    int  len ;
    u32 port = 23 ;
    char host[64] ;
    char cmd[256] ;

    VTY_GET_HOST("Telnet-server", host, sizeof(host), argv[0]); 
    if( 2 == argc ) {
        VTY_GET_INTEGER_RANGE("Port", port, argv[1], 1, 65535) ;
    }
    
    snprintf(cmd, sizeof(cmd), "telnet %s %u", host, port) ;
    vpipe_run(vty, cmd) ;

    return CMD_SUCCESS ;
}
ALIAS(local_telnet_host,
      local_telnet_host_port_cmd,
      "telnet (HOST|A.B.C.D) <1-65535>",
      "Start telnet connection\nTelnet server domain\nTelnet server address\nTelnet server port\n") ;

#define __LOCAL_SHOW_KERNEL_CLIENT
DEFUN(local_show_kernel_client,
	local_show_kernel_client_cmd,
	"show kernel client X:X:X:X:X:X",
	SHOW_STR "Show kernel information\nKernel client information\nMAC format 00:00:00:00:00:00\n")
{
	char line[512]={0};
	FILE *fp=NULL;
	int len=0;
	char cmd[128]={0};

	sprintf(cmd,"echo %s > /proc/fpp/client/mac",argv[0]);
	system(cmd);
		
	fp = fopen("/proc/fpp/client/mac","r");
	if(fp != NULL)
	{
		while(fgets(line,sizeof(line)-1,fp)!=NULL)
		{
			vty_out(vty,"%s%s",line,VTY_NEWLINE);
		}
		fclose(fp);
	}
	
	return CMD_SUCCESS;
}

void local_init(struct thread_master *m)
{
	int i;
	int nodes[] = {VIEW_NODE, VAMD_NODE, VAMD_TECH_NODE, VCSD_NODE, VCSD_TECH_NODE, 0} ;

	master = m;

	files = vector_init(VECTOR_MIN_SIZE);

	install_node(&vamd_node, NULL);
	install_default(VAMD_NODE);
	install_node(&vcsd_node, NULL);
	install_default(VCSD_NODE);
	install_node(&vamd_tech_node, NULL);
	install_default(VAMD_TECH_NODE);
	install_node(&vcsd_tech_node, NULL);
	install_default(VCSD_TECH_NODE);

	// in-reachable node for users 
	install_element(CONFIG_NODE, &local_login_mac_port_cmd);

	/* ping */
	for(i=0; nodes[i] > 0 ; i++) {
		install_element(nodes[i], &local_ping_host_cmd);
		install_element(nodes[i], &local_ping_count_host_cmd);
		install_element(nodes[i], &local_ping_long_host_cmd);
		
		install_element(nodes[i], &local_cli_switch_cmd);
		install_element(nodes[i], &local_vni_tech_cmd);
		
		install_element(nodes[i], &local_tcpdump_cmd);
		install_element(nodes[i], &local_tcpdump_expression_cmd);
		install_element(nodes[i], &local_tcpdump_save_expression_cmd);

		install_element(nodes[i], &local_scp_cmd);

		install_element(nodes[i], &local_timeout_cmd);
		install_element(nodes[i], &local_timeout_min_cmd);
		install_element(nodes[i], &local_show_timeout_cmd);

		install_element(nodes[i], &local_login_mac_cmd);

		install_element(nodes[i], &local_nslookup_cmd);

		install_element(nodes[i], &local_show_tech_cmd);

		install_element(nodes[i], &local_traceroute_cmd);
		install_element(nodes[i], &local_traceroute_options_cmd);

		install_element(nodes[i], &local_radtest_cmd);
		install_element(nodes[i], &local_radtest_simple_cmd);

		install_element(nodes[i], &local_show_kernel_client_cmd);

		install_element(nodes[i], &local_ssh_user_host_cmd);
		install_element(nodes[i], &local_ssh_user_host_port_cmd);

        install_element(nodes[i], &local_telnet_host_cmd);
        install_element(nodes[i], &local_telnet_host_port_cmd);
	}

}

void local_exit(void)
{
	return ;
}
